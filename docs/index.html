<html>

<head>
  <meta charset="utf-8" />
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/numeric/1.2.6/numeric.min.js" integrity="sha256-t7CAuaRhODo/cv00lxyONppujwTFFwUWGkrhD/UB1qM=" crossorigin="anonymous"></script>
  <script src="util.js"></script>
  <script src="tfb-lookup.js"></script>
</head>

<body>
  <style>
    body {
      background-color: #ebebeb;
    }

    .description {
      width: 800px;
      margin-left: 20px;
      margin-top: 20px;
    }

    .filter {
      width: 800px;
      margin-left: 30px;
    }

    #chart {
      margin-top: 20px;
    }
  </style>

  <div class="content">
    <div class="description">
      <h3>Dstats from TechEmpower Benchmarks</h3>
      <p>Bar chart for requests per second / median memory usage / average latency from framework test results.zip downloaded from the <a href="https://tfb-status.techempower.com/results/ad7a361c-c4b7-4942-92f5-d9602804c96d">TechEmpower continuous results site 2018-12-29 result.</a> To save space, this is only showing the top 100 frameworks by requests per second with average latency below 100ms.</p>
    </div>

    <div class="filter">
      <label for="testtype">Test type</label>
      <select id="testtype" onchange="window.testTypeChanged()">
        <option>fortune</option>
        <option>plaintext</option>
        <option>json</option>
      </select>
    </div>

    <div id="chart"></div>
  </div>

</body>

<script>

  window.fetchedData = {};

  function median(a) {
    if (a.length == 0) throw "Cannot take median of empty array";
    var copy = a.slice();
    copy.sort((a, b) => a < b ? -1 : 1);
    if (copy.length % 2 === 0) {
      return (copy[copy.length / 2] + copy[(copy.length / 2) - 1]) / 2.0;
    } else {
      return copy[Math.floor(copy.length / 2)];
    }
  }

  function chartData(testtype) {
    testtype = testtype || 'fortune';
    var testdata = window.fetchedData[testtype];
    console.log('Found ', testtype, 'data: ', testdata);

    var frameworks = Object.keys(testdata);
    var allRps = frameworks
      .map(framework => {
        return {
          name: framework,
          rps: testdata[framework].rpsAndLatency.requestsPerSecond,
          lavg: testdata[framework].rpsAndLatency.latencyAverageMs
        };
      });
    allRps.sort((a, b) => a.rps < b.rps ? 1 : -1);
    var topFrameworks = allRps
      .filter(v => v.lavg < 100) // is it really top if average latency > 100ms?
      .slice(0, 100)
      .map(v => v.name);
    topFrameworks.reverse();

    var colors = topFrameworks.map(framework => {
        var maybeTest = lookup.tests(framework);
        return maybeTest ?
          maybeTest.attributes.language.opaque : 'rgb(122,122,122)';
      });

    var rpsTrace = {
      x: topFrameworks.map(framework => testdata[framework].rpsAndLatency.requestsPerSecond),
      y: topFrameworks,
      xaxis: 'x',
      yaxis: 'y',
      type: 'bar',
      orientation: 'h',
      marker: { color: colors }
    };

    var memoryUsagesTrace = {
      x: topFrameworks.map(framework => median(testdata[framework].memoryUsages.map(v => v/1000000000))),
      y: topFrameworks,
      type: 'bar',
      xaxis: 'x2',
      yaxis: 'y',
      orientation: 'h',
      marker: { color: colors }
    };

    var loadAveragesTrace = {
      x: topFrameworks.map(framework => median(testdata[framework].loadAverages)),
      y: topFrameworks,
      type: 'bar',
      xaxis: 'x3',
      yaxis: 'y',
      orientation: 'h',
      marker: { color: colors }
    };

    var latencyAverageTrace = {
      x: topFrameworks.map(framework => testdata[framework].rpsAndLatency.latencyAverageMs),
      y: topFrameworks,
      type: 'bar',
      xaxis: 'x4',
      yaxis: 'y',
      orientation: 'h',
      marker: { color: colors }
    };

    var data = [rpsTrace, memoryUsagesTrace, latencyAverageTrace];
    var layout = {
      grid: {
        rows: 1, columns: 3,
        pattern: 'independent',
        subplots: [
          ['xy', 'x2y', 'x4y']
        ],
      },

      height: 3000,
      width: 1200,
      xaxis: {
        title: 'Requests per second (max)',
        tickangle: 45,
        side: 'top',
      },
      xaxis2: {
        title: 'Median Memory Usage (GB)',
        tickangle: 45,
        side: 'top',
      },
      xaxis3: {
        title: 'Median Load Average (1min %CPU)',
        tickangle: 45,
        side: 'top',
      },
      xaxis4: {
        title: 'Average Latency (ms)',
        tickangle: 45,
        side: 'top'
      },
      yaxis: {
        zeroline: false,
        gridcolor: '#cccccc',
      },
      margin: {
        t: 100,
        l: 170
      },
      paper_bgcolor: 'rgb(250,250,250)',
      plot_bgcolor: 'rgb(250,250,250)',
      showlegend: false
    };

    console.log('Charting: ', data, layout);
    Plotly.newPlot('chart', data, layout);
  }

  function testTypeChanged() {
    var option = document.getElementById('testtype').value;
    try {
      chartData(option);
    } catch (e) {
      console.error(e);
    }
  }

  fetch('filtered.json')
  .then(response => response.json())
  .then(fetchedData => {
    console.log("Got data: ", fetchedData);
    window.fetchedData = fetchedData;
    testTypeChanged();
  });
</script>
</html>